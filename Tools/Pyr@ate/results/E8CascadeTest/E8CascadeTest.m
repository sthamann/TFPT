(* ::Package:: *)

(* ::Text:: *)
(*This file was automatically generated by PyR@TE 3.*)
(*Model : E8CascadeTest*)
(*Author : E8 Cascade Test*)
(**)
(*Section 1 contains the renormalization group equations.*)
(*Section 2 is a proposition of a minimal working code to solve the RGEs and plot the running couplings.*)
(*Section 3 should be completed by the user since it contains the initial conditions for the running couplings.*)
(* ::Subsection:: *)
(*1. RGEs*)

(* \[Beta]-function definition *)

\[Beta][x_] := 1*Sum[If[With[{j=i}, ValueQ[\[Beta][x, j]]] && (!ValueQ[loops[x]] || i <= loops[x]),  1/(4 Pi)^(2*i)*\[Beta][x,i], 0], {i,1}]*Log[10];


(* Gauge Couplings *)

GaugeCouplings = {gU1Y, gSU2L, gSU3c};

\[Beta][gU1Y, 1] = (41/6)*gU1Y^3;
\[Beta][gSU2L, 1] = -11/6*gSU2L^3;
\[Beta][gSU3c, 1] = -7*gSU3c^3;


(* Yukawa Couplings *)

YukawaCouplings = {Yu, Yd, Ye, yN};

\[Beta][Yu, 1] = -9/4*gSU2L^2*Yu - 8*gSU3c^2*Yu - 17/12*gU1Y^2*Yu + 3*Tr[ConjugateTranspose[Yd].Yd]*Yu + (Tr[ConjugateTranspose[Ye].Ye])*Yu + 3*Tr[ConjugateTranspose[Yu].Yu]*Yu + (Tr[ConjugateTranspose[yN].yN])*Yu - (3/2)*Yd.ConjugateTranspose[Yd].Yu + (3/2)*Yu.ConjugateTranspose[Yu].Yu;
\[Beta][Yd, 1] = -9/4*gSU2L^2*Yd - 8*gSU3c^2*Yd - 5/12*gU1Y^2*Yd + 3*Tr[ConjugateTranspose[Yd].Yd]*Yd + (Tr[ConjugateTranspose[Ye].Ye])*Yd + 3*Tr[ConjugateTranspose[Yu].Yu]*Yd + (Tr[ConjugateTranspose[yN].yN])*Yd + (3/2)*Yd.ConjugateTranspose[Yd].Yd - (3/2)*Yu.ConjugateTranspose[Yu].Yd;
\[Beta][Ye, 1] = -9/4*gSU2L^2*Ye - 15/4*gU1Y^2*Ye + 3*Tr[ConjugateTranspose[Yd].Yd]*Ye + (Tr[ConjugateTranspose[Ye].Ye])*Ye + 3*Tr[ConjugateTranspose[Yu].Yu]*Ye + (Tr[ConjugateTranspose[yN].yN])*Ye + (3/2)*Ye.ConjugateTranspose[Ye].Ye - (3/2)*yN.ConjugateTranspose[yN].Ye;
\[Beta][yN, 1] = -9/4*gSU2L^2*yN - 3/4*gU1Y^2*yN + 3*Tr[ConjugateTranspose[Yd].Yd]*yN + (Tr[ConjugateTranspose[Ye].Ye])*yN + 3*Tr[ConjugateTranspose[Yu].Yu]*yN + (Tr[ConjugateTranspose[yN].yN])*yN - (3/2)*Ye.ConjugateTranspose[Ye].yN + (3/2)*yN.ConjugateTranspose[yN].yN;


(* Quartic Couplings *)

QuarticCouplings = {lambda, lPhi, lHphi};

\[Beta][lambda, 1] = (9/8)*gSU2L^4 + (3/4)*gSU2L^2*gU1Y^2 - 9*gSU2L^2*lambda + (3/8)*gU1Y^4 - 3*gU1Y^2*lambda + 4*lHphi^2 + 24*lambda^2 + 12*lambda*Tr[ConjugateTranspose[Yd].Yd] + 4*lambda*Tr[ConjugateTranspose[Ye].Ye] + 12*lambda*Tr[ConjugateTranspose[Yu].Yu] + 4*lambda*Tr[ConjugateTranspose[yN].yN] - 6*Tr[ConjugateTranspose[Yd].Yd.ConjugateTranspose[Yd].Yd] - 2*Tr[ConjugateTranspose[Ye].Ye.ConjugateTranspose[Ye].Ye] - 6*Tr[ConjugateTranspose[Yu].Yu.ConjugateTranspose[Yu].Yu] - 2*Tr[ConjugateTranspose[yN].yN.ConjugateTranspose[yN].yN];
\[Beta][lPhi, 1] = 2*lHphi^2 + 80*lPhi^2;
\[Beta][lHphi, 1] = -9/2*gSU2L^2*lHphi - 3/2*gU1Y^2*lHphi + 8*lHphi^2 + 32*lHphi*lPhi + 12*lHphi*lambda + 6*lHphi*Tr[ConjugateTranspose[Yd].Yd] + 2*lHphi*Tr[ConjugateTranspose[Ye].Ye] + 6*lHphi*Tr[ConjugateTranspose[Yu].Yu] + 2*lHphi*Tr[ConjugateTranspose[yN].yN];


(* Scalar Mass Couplings *)

ScalarMassCouplings = {mu};

\[Beta][mu, 1] = -9/2*gSU2L^2*mu - 3/2*gU1Y^2*mu + 12*lambda*mu + 6*mu*Tr[ConjugateTranspose[Yd].Yd] + 2*mu*Tr[ConjugateTranspose[Ye].Ye] + 6*mu*Tr[ConjugateTranspose[Yu].Yu] + 2*mu*Tr[ConjugateTranspose[yN].yN];


(* Vacuum-expectation Values *)

Vevs = {vSM, vPQ};

(* Gauge fixing *)
xiGauge = 0;

\[Beta][vSM, 1] = (9/4)*gSU2L^2*vSM + (3/4)*gU1Y^2*vSM - 3*vSM*Tr[ConjugateTranspose[Yd].Yd] - vSM*Tr[ConjugateTranspose[Ye].Ye] - 3*vSM*Tr[ConjugateTranspose[Yu].Yu] - vSM*Tr[ConjugateTranspose[yN].yN];
\[Beta][vPQ, 1] = 0;
(* ::Subsection:: *)
(*2. Solving and plotting functions*)

(* ::Subsubsection::Closed:: *)
(*RG-solving functions*)

(* Solving function *)

RGsolve[initialScale_, range_] := Block[{allCouplings, couplingsToFunction, differentialEquations, initialConditions, allEquations, solutions, yukawaLike},
	(* Define and solve the system of coupled differential equations *)
	allCouplings = Join[GaugeCouplings, YukawaCouplings, QuarticCouplings, ScalarMassCouplings, Vevs];
	couplingsToFunction = # -> #[t] & /@ allCouplings;

	differentialEquations = (#'[t] == (\[Beta][#] /. couplingsToFunction) & /@ allCouplings);
	initialConditions = (#[initialScale] == init[#] & /@ allCouplings);
	allEquations = Join[differentialEquations, initialConditions];

	solutions = NDSolve[allEquations, allCouplings /. couplingsToFunction, {t, range[[1]], range[[2]]}][[1]];

	(* Now split matrix couplings into their individual components *)
	yukawaLike = {{Yu, {3, 3}}, {Yd, {3, 3}}, {Ye, {3, 3}}, {yN, {3, 3}}};
	solutions = Block[{coupling, function, shape},
					coupling = #[[1,0]];
					function = #[[2]];
					If[MemberQ[Flatten@yukawaLike, coupling],
						shape = yukawaLike[[Position[yukawaLike, coupling][[1,1]], 2]];
						Sequence @@ Flatten @ Table[coupling[i,j] -> FunctionInterpolation[If[NumericQ[t], function[[i,j]]], {t, range[[1]], range[[2]]}][t], {i, shape[[1]]}, {j, shape[[2]]}],
						coupling -> function]]& /@ solutions;

	Return[solutions];
];

(* The following function removes from the list the couplings which seem to identically vanish over the energy range *)
DiscardZeroCouplings[range_, solutions_] := Block[{N, testPoints},
	N = 20;
	testPoints =  Range[range[[1]], range[[2]], (range[[2]] - range[[1]])/N];
	Return @ Select[solutions, (DeleteDuplicates[#[[2, 0]] /@ testPoints] != {0}) &];
];
(* ::Subsubsection::Closed:: *)
(*Plot function*)

(* Plotting function handling both real and complex quantities *)

Complexplot[funcs_, {min_, max_}, legends_, plotRange_] := Block[{cplxPos, newFuncs, newLegends},
	cplxPos = If[Head[Chop[funcs[[#]] /. t -> 1/2(max-min)]] === Complex,#, Nothing]& /@ Range[Length[funcs]];
	newFuncs = If[MemberQ[cplxPos, #], Sequence @@ {Re@funcs[[#]], Im@funcs[[#]]}, funcs[[#]]]& /@ Range[Length[funcs]];
	newLegends = If[MemberQ[cplxPos, #], Sequence @@ {Re@legends[[#]], Im@legends[[#]]}, legends[[#]]]& /@ Range[Length[funcs]];

	Return @ Plot[Evaluate @ newFuncs, {t, min, max}, PlotLegends->newLegends, PlotRange->plotRange]
 ]


RGplot[range_, solutions_] := Block[{selectType, toPlot},
	selectType[type_] := Select[solutions, MemberQ[type, If[Head@#[[1]] =!= Symbol, Head@#[[1]], #[[1]]]]&];

	toPlot = selectType[GaugeCouplings];
	If[toPlot =!= {},
		Print["### Gauge Couplings ###"];
		Print @ Complexplot[toPlot[[All, 2]], range, toPlot[[All, 1]], All];
	];

	toPlot = selectType[YukawaCouplings];
	If[toPlot =!= {},
		Print["### Yukawa Couplings ###"];
		Print @ Complexplot[toPlot[[All, 2]], range, toPlot[[All, 1]], All];
	];

	toPlot = selectType[QuarticCouplings];
	If[toPlot =!= {},
		Print["### Quartic Couplings ###"];
		Print @ Complexplot[toPlot[[All, 2]], range, toPlot[[All, 1]], All];
	];

	toPlot = selectType[ScalarMassCouplings];
	If[toPlot =!= {},
		Print["### Scalar Mass Couplings ###"];
		Print @ Complexplot[toPlot[[All, 2]], range, toPlot[[All, 1]], All];
	];

	toPlot = selectType[Vevs];
	If[toPlot =!= {},
		Print["### Vacuum-expectation Values ###"];
		Print @ Complexplot[toPlot[[All, 2]], range, toPlot[[All, 1]], All];
	];
];
(* ::Subsection:: *)
(*3. Actual solving*)


(* Some useful quantities. Energy and mass are in units of Log10[ GeV ] *)

MZ = 91.1876                 // Log10; (* Z boson mass *)
MP = 1.22*10^19              // Log10; (* Planck mass *)
Mp = 1.22*10^19 / Sqrt[8 Pi] // Log10; (* Reduced Planck mass *)

MT = 173.0 // Log10; (* Pole top mass *)

vev = 246.22 // Log10; (* SM Higgs vacuum-expectation value *)


(*** Initial conditions ; Energy range ***)

initialScale = MZ;
range = {0, MP};

(* Gauge Couplings *)

init[gU1Y] = 0;
init[gSU2L] = 0;
init[gSU3c] = 0;

(* Yukawa Couplings *)

init[Yu] = {{0, 0, 0},
            {0, 0, 0},
            {0, 0, 0}};

init[Yd] = {{0, 0, 0},
            {0, 0, 0},
            {0, 0, 0}};

init[Ye] = {{0, 0, 0},
            {0, 0, 0},
            {0, 0, 0}};

init[yN] = {{0, 0, 0},
            {0, 0, 0},
            {0, 0, 0}};

(* Quartic Couplings *)

init[lambda] = 0;
init[lPhi] = 0;
init[lHphi] = 0;

(* Scalar Mass Couplings *)

init[mu] = 0;

(* Vacuum-expectation Values *)

init[vSM] = 0;
init[vPQ] = 0;


(* Definition of the running scheme *)

(loops[#] = 1)& /@ GaugeCouplings;
(loops[#] = 1)& /@ YukawaCouplings;
(loops[#] = 1)& /@ QuarticCouplings;
(loops[#] = 1)& /@ ScalarMassCouplings;
(loops[#] = 1)& /@ Vevs;


(* Now call the functions defined in section 2 *)

solutions = RGsolve[initialScale, range];
solutions = DiscardZeroCouplings[range, solutions];

RGplot[range, solutions]